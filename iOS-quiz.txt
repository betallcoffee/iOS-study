1.Difference Between shallow copy and deep copy?
answer:
Shallow copies duplicate as little as possible. A shallow copy of a collection si a copy of the collection structure, not the elements. With a shallow copy, two collections now share the individual elements.

Deep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the original collection duplicated.

referenceURL:stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy

2.What is advantage of categories? What is difference between implementing a category and inheritance?
answer:
A category is a way to add methods to existing classes. They usually reside in files called "Class+CategoryName.h", like "NSView+CustomAdditions.h" (and .m, of course).

A class extension is a category, except for 2 main difference:
  1. The category has no name. It is declared like this;
    @interface someClass()
    - (void) anadditionalMethod;
    @end

  2. The implementation of the extension must be in the main @implementation block of the file.

It's quite common to see a class extension at the top of a .m file declaring mroe methods on the class, that are then implemented below in the main @implementation section of the class. This is a way to declare "pseudo-private" methods (pseudo-private in that they're not really private, just not externally exposed).

In Class-Extension you're able to overwrite properties from a (public) read-only property to be internally readwrite. And since LLVM 1.5 you're able to do even more: you can now declare instance variable in a class extension so they are gone from the regular interface.

referenceURL:stackoverflow.com/questions/3499704/difference-between-categoryand-class-extension

3.Difference between categories and extension?
Class extensions were added in Objective-C 2.0 to solve two specific problems:
  1. Allow an object to have a "private" interface that is checked by the compiler.
  2. Allow publicly-readable, privately-writable properties.
 
Private Interface
Before Objective-C 2.0, if a developer wanted to have a set of methods in Objective-C, they often declared a "Private" category in the class's implementation file:

@interface MyClass(private)
- (id)awesomePrivateMethod;
@end

However, these private methods were often mixed into the class's @implementation block (not a separate @implementation block for the Private category). And why not? These aren't really extensions to the class; they just make up for the lack of public/private restrictions in Objective-C categories.

The problem is that Objective-C compliers assume that methods declared in a category will be implemented elsewhere, so they don't check to make sure the methods are implemented. Thus, a developer could declare awesomePrivateMethod but fail to implement it, and the compiler wouldn't warn them of the problem. That is the problem you noticed: in a category, you can declare a property (or a method) but fail to get a warning if you never actually implement it -- that's because the complier expects it to be implemented "somewhere" (most likely, in another compilation unit independent of this one).

Enter class extensions. Methods declared in a class extensions are assume to be implemented in the main @implementation block, if they're not, the compiler will issue a warning.

Publicly-Readable, Privately-Writable Properties
It is often beneficial to implement an immutable data structure -- that is, one in which outside code can't use a setter to modify the object's state. However, it can still be nice to have a writable property for internal use. Class extensions allow that: in the public interface, a developer can declare a property to be read-only, but then declare it to be writable in the class extension. To outside code, the property will be read-only, but a seter can be used internally.

So Why Can't I Declare a Writable Property in a Category?
Categories can't add instance variables. A setter often requires some sort of backing storage. It was decided that allowing a category to declare a property that likely required a backing store was A Bad Thing. Hence, a category can't declare a writable property.

They Look Similar, But Are Different
The confusion lies in the idea that a class extension is just an "unnamed category". The syntax is similar and implies this idea; I imagine it was just chosen because it was familiar to Objective-C programmers and, in some ways, class extensions are like categories. They are alike in that both features allow you to add methods (and properties) to an existing class, but they serve different purposes and thus allow different behaviors.

referenceURL:stackoverflow.com/questions/465679/minutia-on-objective-c-categories-and-extensions

4. Difference between protocol in objective-c and interface in java.
First off, a little historical perspective on the topic, from one of the creators of Java. Next, Wikipedia has a moderately helpful section on Objective-C protocols. In particular, understand that Objective-c supports both formal protocols (which  are explicitly declared with the @protocol keyword, the equivalent of a Java interface) and informal protocols (just one or more methods implemented by a class, which can be discoverd via reflection).

If you adopt a formal protocol (Objectvie-C terminology for "implement an interface") the compiler will emit warnings for unimplemented methdos. Just as you would expect in Java. Unlike Java (as skaffman mentioned), if an Objective-C class implements the methods contained in a formal protocol, it is said to "conform" to that protocol, even if its interface doesn't explicitly adopt it. You can test protocol conformance in code (using -conformsToProtocol:) like this:
    if ([myObject conformsToProtocol:@protocol(MyProtocol)]) {
    }
 
As of Objective-C 2.0 (in OS X 10.5 "Leopard" and iOS), formal protocols can now define optional methods, and a class conforms to a protocol as long as it implements all the required methods. You can use the @required (default) and @optional keywords to toggle whether the method declarations that follow must or may be implemented to conform to the protocol. (See the section of Apple's Objective-C 2.0 Programming Language guide that discusses optional protocol methods)

Optional protocol methods open up a lot of flexibility to developers, particularly for implementing delegates and listeners. Instead of extending something like a MouseputAdapter (which can be annoying, since Java is also single-inheritance) or implementing a lot of pointless, empty mehtonds, you can adopt a protocol and implement only the optional methods you care about. With this pattern, the caller checks whether the methods is implemented before invoking it (using -respondsToSelector) like so:
    if ([myObject respondsToSelector:@selector(fillArray:withObject:)]) {
        [myObject fillArray:anArray withObject:foo];
    }

if the overhead of reflectino becomes a problem, you can always cache the boolean result for resue, but resist the urge to optimize prematurely.

They are almost identical. However the one thing that has caught me out, is that unelss you explicily declare that an Objective-C protocol also implements NSObject, references to that protocol don't get access to the methods that NSObject declares (without a compiler warning anyway). With java you can have a reference to an interface, and still call toString() etc on it.
eg:
    Objective-C:
    @protocol MyProtocol
    // Protocol definition
    @end

    id <MyProtocol> myProtocol;

    [myProtocol retain] // Compiler warning

    Java:
    public interface MyInterface {
    // intterface definition
    }

    MyInterface myInterface;

    myInterface.toString(); // Works fine.

    Objective-C (fixed):
    @protocol MyProtocol <NSObject>
    // Protocol definition
    @end

    id <MyProtocol> myProtocol;

    [myProtocol retain] // No Warning

referenceURL:stackoverflow.com/questions/990360/differences-between-java-interfaces-and-objective-c-protocols

5. What are KVO and KVC?
KVC is a way to call property accessor methods, or otherwise access a property, using string identifiers.

What do I mean by "otherwise access"? For KVC purposes, an instance variable with no accessor methods counts as an informal property. It'll get or set the value of the instance variable directly if no matching accessor pair can be found. (Yes, this is not worth using in modern code. Always declare an @property for anything you intend to access elsewhere, and, inversely, don't use KVC to access anything that isn't a public property.)

Property accessor methods are what KVC will call if they exist (preferred, both by KVC and by every sane programmer, over direct ivar access). An accessor may get or set an instance variable, as synthesized accessors do, or access some other storage.

Accessors are implementation, properties are interface, and KVC is one way to use them.

And how do I distinguish between dots that call setValue:forKeyPath: and simple accessors?

A key path is a string, whereas a property-access expression is an expression. The compiler evaluates a property-access expression and translates it into one or more Objective-C messages, whereas a key path is evaluated by KVC at run time.

So, when you use a key path:
[someObject setValue:theValue forKeyPath:@"foo.bar.baz"];

You know it's a key path because (1) it's a string, as indicated in this case by the string-iteral syntax @"...", and (2) you're passing the key path string to setValue:forKeyPath: for it to evaluate.

Using a key path is using KVC to access the named properties. It will send any relevant accessor messages on your behalf.

When you use a property-access expression:
someOject.foo.bar.baz = theValue;
You know it's a property access expression because you are not identifying the properties with a string. You are accessing them yourself, in your own code.

There isn't much reason to use KVC in any form; when you know the property at authorship/compile time, it's best to have an @property declared and to access the property yourself, whether with property access expressions or message expressions. The time to use KVC is when you don't know what property you want to access until run time, which is pretty rare. It's mainly a building-block technology behind KVO. Cocoa Bindings, parts of Core Animation, etc.

How you make a property KVC compliant depends on whether that property is an attribute, a to-one relationship, or a to-many relationship. For attribute and to-one relationship, a class must implement at least one of the follwing in the given order of preference(key refers to the property key)
    The class has a declared property with the name key.
    It implements accessor methods named key and, if the property is mutable, setKey:. (If the property is a Boolean attribute, the getter accessor method has the form isKey.)
    It declares an instance variable of the form key or _key.
Implementing KVC compliant for a to-many relationship is a more complicated procedure.

Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects
It is particularly useful for communication between model and controller layers in an application.
You can observe properties including simple attributes, to-one relationships, and to-many relationships. Observers of to-many relationships are informed of the type of change made--as well as which objects are involved in the change.
    Observing Object must register as an observer of the Observered Object's property by sending an addObserver:forKeyPath:options:context: message.
    In order to respond to change notifications, the observer must implement the observeValueForKeyPath:ofObject:change:context: method. This method implementation defines how the observer responds to change notifications. It is in this method that you can customize your response to a change in one of the observed properties. 
    The observeValueForKeyPath:ofObject:change:context: method is automatically invoked when the value of an observed property is changed in a KVO-compliant manner, or if a key upon which it depends is changed.

referenceURL:stackoverflow.com/questions/8191373/whats-the-difference-between-kev-and-properties


6. What is purpose of delegates?
When an object receives a request, the object can either handle the request or pass the request on to a second object to do the work.
If the objects decides to pass the request on, you say that the object has forwarded responsibility for handing the requests to the second object.

The delegate pattern is used to have someone else actually do the work.
    when you want to perform some additional actions before/after your delegate 
    when you have imcompatible interfaces and you want to adapt one to the other.
You get the original object and delegate to it from methods that conform to the desired interface.
    when you want to hide some complexity from the user of your class, you can have methods that delegate to different actual works. 
For example, a Car can have start(), openWindow() and brake(), but each of these methods will actually delegate to the engine, windows and braking system.
referenceURL:stackoverflow.com/questions/7168714/what-is-the-purpose-of-a-delegation-pattern

7. What are mutable and immutable types in objective c?
A mutable object can be mutated or changed. An immutable object cannot.
The advantages of your mutable objects is obvious, but they should only be used when necessary (which is a lot less often than you think) as they take up more memory than immutable objects.

referenceURL:stackoverflow.com/questions/7071096/what-is-difference-between-mutable-and-immutable.

