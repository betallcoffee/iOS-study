1.Difference Between shallow copy and deep copy?
answer:
Shallow copies duplicate as little as possible. A shallow copy of a collection si a copy of the collection structure, not the elements. With a shallow copy, two collections now share the individual elements.

Deep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the original collection duplicated.

referenceURL:stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy

2.What is advantage of categories? What is difference between implementing a category and inheritance?
answer:
A category is a way to add methods to existing classes. They usually reside in files called "Class+CategoryName.h", like "NSView+CustomAdditions.h" (and .m, of course).

A class extension is a category, except for 2 main difference:
  1. The category has no name. It is declared like this;
    @interface someClass()
    - (void) anadditionalMethod;
    @end

  2. The implementation of the extension must be in the main @implementation block of the file.

It's quite common to see a class extension at the top of a .m file declaring mroe methods on the class, that are then implemented below in the main @implementation section of the class. This is a way to declare "pseudo-private" methods (pseudo-private in that they're not really private, just not externally exposed).

In Class-Extension you're able to overwrite properties from a (public) read-only property to be internally readwrite. And since LLVM 1.5 you're able to do even more: you can now declare instance variable in a class extension so they are gone from the regular interface.

referenceURL:stackoverflow.com/questions/3499704/difference-between-categoryand-class-extension

3.Difference between categories and extension?
Class extensions were added in Objective-C 2.0 to solve two specific problems:
  1. Allow an object to have a "private" interface that is checked by the compiler.
  2. Allow publicly-readable, privately-writable properties.
 
Private Interface
Before Objective-C 2.0, if a developer wanted to have a set of methods in Objective-C, they often declared a "Private" category in the class's implementation file:

@interface MyClass(private)
- (id)awesomePrivateMethod;
@end

However, these private methods were often mixed into the class's @implementation block (not a separate @implementation block for the Private category). And why not? These aren't really extensions to the class; they just make up for the lack of public/private restrictions in Objective-C categories.

The problem is that Objective-C compliers assume that methods declared in a category will be implemented elsewhere, so they don't check to make sure the methods are implemented. Thus, a developer could declare awesomePrivateMethod but fail to implement it, and the compiler wouldn't warn them of the problem. That is the problem you noticed: in a category, you can declare a property (or a method) but fail to get a warning if you never actually implement it -- that's because the complier expects it to be implemented "somewhere" (most likely, in another compilation unit independent of this one).

Enter class extensions. Methods declared in a class extensions are assume to be implemented in the main @implementation block, if they're not, the compiler will issue a warning.

Publicly-Readable, Privately-Writable Properties
It is often beneficial to implement an immutable data structure -- that is, one in which outside code can't use a setter to modify the object's state. However, it can still be nice to have a writable property for internal use. Class extensions allow that: in the public interface, a developer can declare a property to be read-only, but then declare it to be writable in the class extension. To outside code, the property will be read-only, but a seter can be used internally.

So Why Can't I Declare a Writable Property in a Category?
Categories can't add instance variables. A setter often requires some sort of backing storage. It was decided that allowing a category to declare a property that likely required a backing store was A Bad Thing. Hence, a category can't declare a writable property.

They Look Similar, But Are Different
The confusion lies in the idea that a class extension is just an "unnamed category". The syntax is similar and implies this idea; I imagine it was just chosen because it was familiar to Objective-C programmers and, in some ways, class extensions are like categories. They are alike in that both features allow you to add methods (and properties) to an existing class, but they serve different purposes and thus allow different behaviors.

referenceURL:stackoverflow.com/questions/465679/minutia-on-objective-c-categories-and-extensions

4. Difference between protocol in objective-c and interface in java.
First off, a little historical perspective on the topic, from one of the creators of Java. Next, Wikipedia has a moderately helpful section on Objective-C protocols. In particular, understand that Objective-c supports both formal protocols (which  are explicitly declared with the @protocol keyword, the equivalent of a Java interface) and informal protocols (just one or more methods implemented by a class, which can be discoverd via reflection).

If you adopt a formal protocol (Objectvie-C terminology for "implement an interface") the compiler will emit warnings for unimplemented methdos. Just as you would expect in Java. Unlike Java (as skaffman mentioned), if an Objective-C class implements the methods contained in a formal protocol, it is said to "conform" to that protocol, even if its interface doesn't explicitly adopt it. You can test protocol conformance in code (using -conformsToProtocol:) like this:
    if ([myObject conformsToProtocol:@protocol(MyProtocol)]) {
    }
 
As of Objective-C 2.0 (in OS X 10.5 "Leopard" and iOS), formal protocols can now define optional methods, and a class conforms to a protocol as long as it implements all the required methods. You can use the @required (default) and @optional keywords to toggle whether the method declarations that follow must or may be implemented to conform to the protocol. (See the section of Apple's Objective-C 2.0 Programming Language guide that discusses optional protocol methods)

Optional protocol methods open up a lot of flexibility to developers, particularly for implementing delegates and listeners. Instead of extending something like a MouseputAdapter (which can be annoying, since Java is also single-inheritance) or implementing a lot of pointless, empty mehtonds, you can adopt a protocol and implement only the optional methods you care about. With this pattern, the caller checks whether the methods is implemented before invoking it (using -respondsToSelector) like so:
    if ([myObject respondsToSelector:@selector(fillArray:withObject:)]) {
        [myObject fillArray:anArray withObject:foo];
    }

if the overhead of reflectino becomes a problem, you can always cache the boolean result for resue, but resist the urge to optimize prematurely.

They are almost identical. However the one thing that has caught me out, is that unelss you explicily declare that an Objective-C protocol also implements NSObject, references to that protocol don't get access to the methods that NSObject declares (without a compiler warning anyway). With java you can have a reference to an interface, and still call toString() etc on it.
eg:
    Objective-C:
    @protocol MyProtocol
    // Protocol definition
    @end

    id <MyProtocol> myProtocol;

    [myProtocol retain] // Compiler warning

    Java:
    public interface MyInterface {
    // intterface definition
    }

    MyInterface myInterface;

    myInterface.toString(); // Works fine.

    Objective-C (fixed):
    @protocol MyProtocol <NSObject>
    // Protocol definition
    @end

    id <MyProtocol> myProtocol;

    [myProtocol retain] // No Warning

referenceURL:stackoverflow.com/questions/990360/differences-between-java-interfaces-and-objective-c-protocols

